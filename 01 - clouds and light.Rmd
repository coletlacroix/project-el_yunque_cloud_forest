---
title: "01 - clouds and light"
author: "Cole LaCroix"
date: "2025-07-30"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, message=FALSE, warning=FALSE, echo=FALSE}
# libraries
library(dplyr)
library(tidyr)
library(ggplot2)
library(zoo)
library(forecast)
library(lubridate)
library(broom)

# Uploading weather data.
# Data acquired from NASA POWER data set. 
# https://power.larc.nasa.gov/data-access-viewer/
# This website allows you to select a point on the map to acquire data from. 
# I selected from lat 18.38 lon -65.60, northeast of el yunque near the coast.
# This gives best estimate of variables as they come from the sea to the forest.

weather_data <- read.csv(
  "/Users/colelacroix/Downloads/POWER_Point_Daily_19810101_20241231_018d38N_065d62W_LST.csv",
  skip = 13, header = TRUE
)
```


```{r}
glimpse(weather_data)
range(weather_data$RH2M)
```


```{r}
# ----- setting up dates -----
weather_data$YEAR <- as.numeric(weather_data$YEAR)
weather_data$DOY <- as.numeric(weather_data$DOY)
weather_data$Date <- as.Date(weather_data$DOY - 1, origin = paste0(weather_data$YEAR, "-01-01"))
```


```{r}
# ----- estimating cloud base height -----
estimate_cbh <- function(temp_c, rh_percent) {

  # finding dew pt using Lawrence method (described as accurate above 50% rh)
  #https://journals.ametsoc.org/view/journals/bams/86/2/bams-86-2-225.xml?tab_body=pdf
  dew_point <- temp_c - ((100 - rh_percent)/5)
  
  # applying the lapse rate
  # https://www.eoas.ubc.ca/courses/atsc113/flying/met_concepts/01-met_concepts/01d-ceilings/zlcl.html
  (temp_c - dew_point) * 125
}
weather_data$CBH_meters <- estimate_cbh(weather_data$T2M, weather_data$RH2M)

glimpse(weather_data)
```


```{r}
# ----- estimating solar radiation -----

# latitude as sourced from NASA POWER portal
latitude <- 18.38
lat_rad <- latitude * pi / 180

# as indicated by FAO (appropriate for coastal areas)
# https://www.fao.org/4/x0490e/x0490e07.htm#chapter%203%20%20%20meteorological%20data
k_rs <- 0.19

calculate_ra <- function(doy, lat_rad) {
  # solar constant
  G_sc <- 0.0820
  
  # inverse relative distance, earth to sun
  dr <- 1 + 0.033 * cos(2 * pi * doy / 365)
  
  # solar declination 
  solar_decl <- 0.409 * sin(2 * pi * doy / 365 - 1.39)
  
  # sunset hour angle
  ws <- acos(-tan(lat_rad) * tan(solar_decl))
  
  # incoming radiation
  (24 * 60 / pi) * G_sc * dr * (ws * sin(lat_rad) * sin(solar_decl) + cos(lat_rad) * cos(solar_decl) * sin(ws))
}
```


```{r}
# ----- estimating cloudiness -----

# calculating extraterrestrial radiation
weather_data$Ra <- calculate_ra(weather_data$DOY, lat_rad)

# calculating solar radiation at the surface 
weather_data$Rs_MJ_m2_day <- k_rs * sqrt(weather_data$T2M_MAX - weather_data$T2M_MIN) * weather_data$Ra

# cloudiness index
weather_data$Kt <- weather_data$Rs_MJ_m2_day / weather_data$Ra

# cloudy day binary (.25 described as value for dense cloud cover)
weather_data$cloudy_day <- ifelse(weather_data$Kt < 0.25, 1, 0)
```


```{r}
# ----- estimating cloud immersion at different elevations -----

elevation_bands <- seq(150, 1000, by = 25)
immersion_daily <- data.frame(Date = weather_data$Date)
for (elev in elevation_bands) {
  immersion_daily[[paste0("Elev_", elev, "m")]] <- ifelse(
    weather_data$cloudy_day == 1 & elev >= weather_data$CBH_meters, 1, 0
  )
}
```


```{r}
# ----- Creating a 1000-day rolling average -----

rolling_cloud_immersion <- immersion_daily %>%
  mutate(across(starts_with("Elev_"), ~ rollapply(
    .x, width = 1000, FUN = function(x) mean(x, na.rm = TRUE) * 100,
    fill = NA, align = "right"
  )))
```


```{r}
# ----- Creating times series objects for decomposition -----

temp_ts <- ts(weather_data$T2M, start = c(min(weather_data$YEAR)), frequency = 365.25)
rh_ts <- ts(weather_data$RH2M, start = c(min(weather_data$YEAR)), frequency = 365.25)
cbh_ts <- ts(weather_data$CBH_meters, start = c(min(weather_data$YEAR)), frequency = 365.25)

temp_stl <- stl(temp_ts, s.window = "periodic")
rh_stl <- stl(rh_ts, s.window = "periodic")
cbh_stl <- stl(cbh_ts, s.window = "periodic")
```


```{r}
plot(temp_stl, main = "STL Decomposition of Average Temperature (T2M)")
```


```{r}
plot(rh_stl, main = "STL Decomposition of Relative Humidity (RH2M)")
```


```{r}
plot(cbh_stl, main = "STL Decomposition of Cloud Base Height (CBH_meters)")
```


```{r}
# ----- Plotting cloud base height -----

ggplot(weather_data, aes(x = Date, y = CBH_meters)) +
  geom_point(alpha = 0.3, color = "lightblue") +
  geom_smooth(method = "loess", span = 2, color = "darkblue", size = 1.2) +
  labs(
    title = "Estimated Cloud Base Height (Smoothed Trend)",
    x = "Date", y = "Cloud Base Height (meters)"
  ) + theme_minimal()
```


```{r}
# ----- Cloud base height trend zoomed in -----

# extract trend component
cbh_trend <- cbh_stl$time.series[, "trend"]

# create a data frame with Date and trend
cbh_trend_df <- data.frame(
  Date = weather_data$Date,
  Trend = as.numeric(cbh_trend)
)

# calculate max and min of the trend
trend_max <- max(cbh_trend_df$Trend, na.rm = TRUE)
trend_min <- min(cbh_trend_df$Trend, na.rm = TRUE)

ggplot(cbh_trend_df, aes(x = Date, y = Trend)) +
  geom_line(color = "steelblue", size = 1) +
  geom_hline(yintercept = trend_max, linetype = "dashed", color = "red") +
  geom_hline(yintercept = trend_min, linetype = "dashed", color = "blue") +
  labs(
    title = "Trend Component of Cloud Base Height (STL)",
    subtitle = "Dashed lines show max (red) and min (blue) trend values",
    x = "Date", y = "CBH Trend (meters)"
  ) +
  theme_minimal()

```


```{r, warning=FALSE}
# ----- Cloud immersion(%) at 750m through time -----

# In its atlas, the forest service depicts the cloud immersion line at 600m. 
# (preface, VI) https://www.srs.fs.usda.gov/pubs/gtr/gtr_srs193.pdf

immersion_daily <- immersion_daily %>%
  mutate(Rolling_1000day_750m = rollapply(Elev_750m, width = 1000, FUN = function(x) mean(x, na.rm = TRUE) * 100, fill = NA, align = "right"))

ggplot(immersion_daily, aes(x = Date, y = Rolling_1000day_750m)) +
  geom_line(color = "lightblue", size = .5) +
  geom_smooth(method = "loess", span = 0.5, color = "navy", se = FALSE) +
  labs(
    title = "Rolling 1000-Day Cloud Immersion at 750m Elevation",
    x = "Date", y = "% Days Immersed in Cloud"
  ) + theme_minimal()
```


```{r}
# ----- Plotting solar radiation -----

ggplot(weather_data, aes(x = Date, y = Rs_MJ_m2_day)) +
  geom_point(alpha = 0.3, color = "orange") +
  geom_smooth(method = "loess", span = 2, color = "red", size = 1.2) +
  labs(
    title = "Estimated Daily Solar Radiation (Smoothed Trend)",
    subtitle = "Hargreaves Method",
    x = "Date", y = "Solar Radiation (MJ/m²/day)"
  ) + theme_minimal()
```


```{r}
# ------ Solar radiation trend zoomed in -----

# fit LOESS 
loess_fit <- loess(Rs_MJ_m2_day ~ as.numeric(Date), data = weather_data, span = 0.5)
weather_data$Rs_smoothed <- predict(loess_fit)

# calculate bounds
rs_max <- max(weather_data$Rs_smoothed, na.rm = TRUE)
rs_min <- min(weather_data$Rs_smoothed, na.rm = TRUE)


ggplot(weather_data, aes(x = Date)) +
  geom_line(aes(y = Rs_smoothed), color = "red", size = 1.2) +
  geom_hline(yintercept = rs_max, linetype = "dashed", color = "darkred") +
  geom_hline(yintercept = rs_min, linetype = "dashed", color = "darkblue") +
  labs(
    title = "Smoothed Solar Radiation Trend Over Time",
    subtitle = "Hargreaves Method — Dashed Lines Show Max and Min of Trend",
    x = "Date", y = "Solar Radiation (MJ/m²/day)"
  ) +
  theme_minimal()
```


```{r}
# ----- Plot CBH colored by cloudiness -----

weather_data$cloudy_pct_1000day <- rollapply(
  weather_data$cloudy_day, width = 1000,
  FUN = function(x) mean(x, na.rm = TRUE) * 100,
  align = "right", fill = NA
)


ggplot(weather_data, aes(x = Date, y = CBH_meters, color = cloudy_pct_1000day)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "loess", span = 1.5, color = "black", se = FALSE, size = .7) +
  scale_color_viridis_c(option = "plasma", direction = -1, name = "% Cloudy Days (1000-Day Rolling)") +
  labs(
    title = "Cloud Base Height Colored by % of Cloudy Days (1000-Day Rolling)",
    x = "Date", y = "Cloud Base Height (meters)"
  ) + theme_minimal()
```

```{r}
modis_data <- read.csv("/Users/colelacroix/Downloads/MODIS_Monthly_TerraAqua_AOI.csv")
glimpse(modis_data)
```

```{r analysis_all, message=FALSE, warning=FALSE, fig.width=7, fig.height=5}

# ---- 1) Clean & plot MODIS monthly ----
modis <- modis_data %>%
  mutate(
    month = as.Date(paste0(month, "-01")),
    cth_km = as.numeric(cth_km),
    cot_mean = as.numeric(cot_mean),
    cloud_fraction = as.numeric(cloud_fraction)
  ) %>%
  arrange(month)

modis_long <- modis %>%
  pivot_longer(c(cth_km, cot_mean, cloud_fraction),
               names_to = "metric", values_to = "value")

p_modis <- ggplot(modis_long, aes(month, value)) +
  geom_line() +
  facet_wrap(~ metric, scales = "free_y", ncol = 1) +
  scale_x_date(date_labels = "%Y", date_breaks = "2 years") +
  labs(title = "MODIS Monthly over AOI (Terra + Aqua mean)",
       x = "Month", y = "Value") +
  theme_minimal()
print(p_modis)

# ---- 2) POWER daily -> monthly aggregation ----
# Uses your existing 'weather_data' (already built earlier in your Rmd)
power_monthly <- weather_data %>%
  mutate(month = floor_date(Date, "month")) %>%
  group_by(month) %>%
  summarise(
    n_days             = n(),
    cbh_m_mean         = mean(CBH_meters, na.rm = TRUE),  # meters
    cloudy_frac        = mean(cloudy_day, na.rm = TRUE),  # 0–1
    Kt_mean            = mean(Kt, na.rm = TRUE),          # clearness index
    Rs_MJ_m2_day_mean  = mean(Rs_MJ_m2_day, na.rm = TRUE)
  ) %>% ungroup()

pm_long <- power_monthly %>%
  select(month, cbh_m_mean, cloudy_frac, Kt_mean) %>%
  pivot_longer(-month, names_to = "metric", values_to = "value")

p_power <- ggplot(pm_long, aes(month, value)) +
  geom_line() +
  facet_wrap(~ metric, scales = "free_y", ncol = 1) +
  scale_x_date(date_labels = "%Y", date_breaks = "2 years") +
  labs(title = "POWER Monthly Aggregates (from daily)",
       x = "Month", y = "Value") +
  theme_minimal()
print(p_power)

# ---- 3) Join & evaluate correlations ----
joined <- modis %>%
  inner_join(power_monthly, by = "month") %>%
  mutate(cbh_km_mean = cbh_m_mean / 1000)  # km to match MODIS CTH

# 3a) Correlations with p-values
corr_results <- list(
  CTH_vs_CBHkm  = cor.test(joined$cth_km, joined$cbh_km_mean),
  CF_vs_Cloudy  = cor.test(joined$cloud_fraction, joined$cloudy_frac),
  COT_vs_Kt     = cor.test(joined$cot_mean, joined$Kt_mean, use = "complete.obs")
)

corr_table <- bind_rows(
  tidy(corr_results$CTH_vs_CBHkm)  %>% mutate(pair = "MODIS CTH (km) vs POWER CBH (km)"),
  tidy(corr_results$CF_vs_Cloudy)  %>% mutate(pair = "MODIS Cloud Fraction vs POWER Cloudy Fraction"),
  tidy(corr_results$COT_vs_Kt)     %>% mutate(pair = "MODIS COT vs POWER Kt")
) %>% select(pair, estimate, p.value, conf.low, conf.high, method)

print(corr_table)

# 3b) Scatterplots with linear fits & r
plot_scatter_lm <- function(df, xvar, yvar, xlab, ylab, note=NULL) {
  r <- suppressWarnings(cor(df[[xvar]], df[[yvar]], use="complete.obs"))
  ggplot(df, aes(.data[[xvar]], .data[[yvar]])) +
    geom_point(alpha = 0.6) +
    geom_smooth(method = "lm", se = TRUE) +
    labs(title = paste0(ylab, " vs ", xlab),
         subtitle = paste0("Pearson r = ", round(r, 3),
                           if (!is.null(note)) paste0(" — ", note) else ""),
         x = xlab, y = ylab) +
    theme_minimal()
}

print(plot_scatter_lm(joined, "cth_km", "cbh_km_mean",
       "MODIS Cloud-Top Height (km)", "POWER Cloud Base Height (km)"))
print(plot_scatter_lm(joined, "cloud_fraction", "cloudy_frac",
       "MODIS Cloud Fraction (0–1)", "POWER Cloudy-Day Fraction (0–1)"))
print(plot_scatter_lm(joined, "cot_mean", "Kt_mean",
       "MODIS Cloud Optical Thickness (unitless)", "POWER Clearness Index (Kt)",
       note = "Expect negative relationship"))

# 3c) Simple linear models
lm_cth  <- lm(cbh_km_mean ~ cth_km, data = joined)
lm_cf   <- lm(cloudy_frac ~ cloud_fraction, data = joined)
lm_cot  <- lm(Kt_mean ~ cot_mean, data = joined)

print(tidy(lm_cth));  print(glance(lm_cth))
print(tidy(lm_cf));   print(glance(lm_cf))
print(tidy(lm_cot));  print(glance(lm_cot))

# 3d) (Optional) quick lag scan: -6..+6 months, report top 3 by |r|
scan_lags <- function(x, y, max_lag = 6) {
  res <- lapply(-max_lag:max_lag, function(L) {
    if (L < 0) {
      df <- tibble(x = dplyr::lead(x, -L), y = y)   # x leads
      lag_txt <- paste0("x leads ", abs(L), "m")
    } else if (L > 0) {
      df <- tibble(x = dplyr::lag(x,  L), y = y)    # y leads
      lag_txt <- paste0("y leads ", L, "m")
    } else {
      df <- tibble(x = x, y = y); lag_txt <- "no lag"
    }
    r <- suppressWarnings(cor(df$x, df$y, use = "complete.obs"))
    tibble(lag = L, label = lag_txt, r = r)
  })
  bind_rows(res) %>% arrange(desc(abs(r)))
}

lags_cth <- scan_lags(joined$cth_km, joined$cbh_km_mean)
lags_cf  <- scan_lags(joined$cloud_fraction, joined$cloudy_frac)
lags_cot <- scan_lags(joined$cot_mean, joined$Kt_mean)

print(head(lags_cth, 3))
print(head(lags_cf, 3))
print(head(lags_cot, 3))

```

